= Map! datatype
:toc:
:numbered:

== 概要

A map represents an associative array of key/value pairs. It provides a fast read access (using an hashtable internally) and a convenient, dedicated syntax. Unlike the `hash!` datatype, a map is not a series, so does not have a concept of offset or positions. Conceptually, the `map!` datatype lies between the `hash!` and `object!` datatypes.

== 字面量语法
----
#(<key> <value>...)

<key>   : hashed key, accepted types are: any-word!, any-string!, number!, char!, pair!, tuple!
<value> : any-type! value
----
== 构造语法
----
make map! <spec>

<spec> : block of key/value pairs or an integer value
----
If the _spec_ argument is an integer, an empty map! is created with a pre-allocated number of slots (usually in order to populate the map dynamically).

Notes:

* the map body or the spec block have to contain an *even* number of elements, or else, an error will be generated. 
* values are not *reduced*, so construction syntax is required for some special values, like logic!.

Examples:
----
#(a: 1 b: 2)
== #(
    a: 1
    b: 2
)

make map! [a 1 'b 2 "c" 3]
== #(
    a: 1
    b: 2
    "c" 3
)
----
If the key is of *any-word!* type, the key type is converted to *set-word!* in the map, in order to make the map content look more like pairs of keys with value assigned. Though, in order to access word keys, there is no requirement to provide a set-word, for practical reasons (easier construction, especially in paths), simple words can be used. Similarly, `keys-of` reflector (described in Reflection section below), will return words instead of set-words, as it simplifies further processing (especially matching operations are easier with words rather than set-words).

Notes:

* Like hash! and block!, map! is **case-preserving**, and **case-insensitive for lookup** by default.
* If a `none` value is specified as value, the key will not be created (see "Deleting keys" section).
* All the keys are deep copied on creation of the map.
* Series! values are not copied on creation of the map, the choice is left to the user (this optimizes resources for the common use-case).

Another way to create a new map is to use the `copy` action on an existing one.

== 获取值

用路径：
----
<map>/<key>
get '<map>/<key>

<map> : word referring to a map! value
<key> : word key
----

用`select`动作：
---- 
select <map> <key>

<map> : map value
<key> : any valid key type
----
所有获取值的操作都是大小写不敏感的，如果想要区分大小写，需要用`/case`细化：
----
get/case '<map>/<key>
select/case <map> <key>
----
如果访问一个map中不存在的key，结果将是`none`。

例子：

----
m: #(Ab: 2 aB: 5 ab: 10)
m/ab
== 2
select m 'aB
== 2
get/case 'm/aB
== 5
select/case m 'ab
== 10
----

== 改变键和值

Using paths:
----
<map>/<key>: <value>
set '<map>/<key> <value>

<map>   : word referring to a map! value
<key>   : word key to select a value in the map
<value> : any value
----

Using modifying action:
---- 
put <map> <key> <value>

<map> : map value
<key> : any valid key value to a select a value in the map
----
Making bulk changes:
----
extend <map> <spec>

<map>  : a map value
<spec> : block of name/value pairs (one or more pairs)
----

All these write accesses are case-insensitive. In order to have a case-sensitive lookup, the `/case` refinement needs to be used where available:
----
set/case '<map>/<key> <value>
put/case <map> <key> <value>
extend/case <map> <spec>
----

`extend` native can accept many keys at the same time, so it is convenient for bulk changes.

Notes:

* setting a key that does not exist previously in the map, **will simply create it**.
* adding an existing key will change the key value and not add a new one (case-insensitive matching by default).

Examples:
----
m: #(Ab: 2 aB: 5 ab: 10)
m/ab: 3
m
== #(
    Ab: 3
    aB: 5
    ab: 10
)

put m 'aB "hello"
m
== #(
    Ab: "hello"
    aB: 5
    ab: 10
)

set/case 'm/aB 0
m
== #(
    Ab: "hello"
    aB: 0
    ab: 10
)
set/case 'm/ab 192.168.0.1
== #(
    Ab: "hello"
    aB: 0
    ab: 192.168.0.1
)

m: #(%cities.red 10)
extend m [%cities.red 99 %countries.red 7 %states.red 27]
m
== #(
    %cities.red 99
    %countries.red 7
    %states.red 27
)
----

== 删除键

要删除map中的key/value，只要设置key为`none`即可，具体可以采用以下几种方式：

例子：
----
m: #(a: 1 b 2 "c" 3 d: 99)
m
== #(
    a: 1
    b: 2
    "c" 3
    d: 99
)
m/b: none
put m "c" none
extend m [d #[none]]
m
== #(
    a: 1
)
----

注意：Construction syntax is required in the above example in order to pass a `none!` value and not a `word!` value (just one way to construct the spec block needed there).

你也可以用`clear`一次性清空map：
----
clear #(a 1 b 2 c 3)
== #()
----

== 反射

* `find` 检查map中是否存在指定的key。如果存在返回`true`，否则返回`none`。

 find #(a 123 b 456) 'b
 == true

* `length?` 返回map中key/value的个数。

 length? #(a 123 b 456)
 == 2

* `keys-of` 返回包含map中所有key的block(set-words被转换为words)。

 keys-of #(a: 123 b: 456)
 == [a b]

* `values-of` 返回包含map中所有value的block。

 values-of #(a: 123 b: 456)
 == [123 456]

* `body-of` 返回包含map中所有key/value的block。

 body-of #(a: 123 b: 456)
 == [a: 123 b: 456]
